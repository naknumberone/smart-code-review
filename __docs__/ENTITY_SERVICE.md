# Entity Service - Извлечение сущностей из кода

## Цель

Найти в измененных файлах конкретные функции, классы и другие сущности, которые были затронуты изменениями. Не весь файл целиком, а именно те части, которые изменились.

## Зачем это нужно

Когда в файле 500 строк кода, а изменились только 2 функции - нам нужны только эти 2 функции. Так мы экономим токены LLM и делаем review более точным.

## Как это работает

### Шаг 1: Получаем diff

На входе приходит список файлов с их diff:
```
File: components/Button.tsx
Diff:
@@ -15,3 +15,5 @@
  export function Button() {
-   return <button>Click</button>
+   const text = "Click me"
+   return <button>{text}</button>
  }
```

### Шаг 2: Парсим измененные строки

Из diff извлекаем номера строк, которые изменились:
```
@@ -15,3 +15,5 @@  →  строки 15-19 изменены (5 строк начиная с 15)
```

### Шаг 3: Парсим весь файл через tree-sitter

Tree-sitter - это инструмент, который понимает синтаксис языка и строит AST (дерево разбора кода). Он умеет находить:
- Функции (`function Button() { ... }`)
- Классы (`class MyClass { ... }`)
- Переменные (`const x = ...`)
- Экспорты (`export function ...`)

Для каждой сущности мы знаем:
- Имя
- Номера строк (где начинается, где заканчивается)
- Полный код

### Шаг 4: Находим пересечения

Смотрим, какие сущности пересекаются с измененными строками:

```
Функция Button: строки 15-19
Измененные строки: 17-18
→ Пересечение есть! Берем всю функцию.
```

### Шаг 5: Разделяем на экспорты и локальный код

**Экспорты (top_level)** - сущности, которые доступны из других файлов:
```typescript
export function Button() { ... }  // ← экспорт
export class Api { ... }          // ← экспорт
```

**Локальный код (local_code)** - внутренние функции, которые используются только внутри файла:
```typescript
function helperFunction() { ... }  // ← локальный
const CONSTANT = 123              // ← локальный
```

## Результат

На выходе получаем `FileEntities` для каждого файла:

```python
FileEntities(
    path="components/Button.tsx",
    top_level=["Button"],  # экспортированные имена
    local_code=[
        LocalCodeBlock(
            code="export function Button() {\n  const text = \"Click me\"\n  return <button>{text}</button>\n}",
            start_line=15,
            end_line=19
        )
    ]
)
```

## Почему это важно

1. **Экономим токены** - отправляем в LLM только измененный код, а не весь файл
2. **Знаем имена** - по именам из `top_level` ищем, где эти функции используются (см. Impact Service)
3. **Полный контекст** - LLM видит не только diff, но и полную функцию целиком

## Поддерживаемые языки

Сейчас поддерживаются:
- TypeScript (`.ts`, `.tsx`)
- JavaScript (`.js`, `.jsx`)

Легко добавить другие языки - достаточно указать маппинг расширения на язык tree-sitter в `LANGUAGE_MAP`.
